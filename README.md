# Задачи: concurrency, алгоритмы и структуры данных

## 1.1 **Композиция (наследование через встраивание)**

> **Задача:** Дана структура `Human`. Реализовать встраивание её методов в структуру `Action`, используя композицию.

**Подсказка:** используйте embedded struct, чтобы `Action` имел доступ ко всем методам `Human`.

---

## 1.2 **Конкурентное вычисление квадратов**

> **Задача:** Конкурентно рассчитать квадраты чисел из массива `[2,4,6,8,10]` и вывести результаты.

**Подсказка:** Запустить несколько горутин, каждая из которых возводит число в квадрат.

---

## 1.3 **N воркеров и канал**

> **Задача:** Постоянно записывать данные в канал в главной горутине, и запускать `N` воркеров, которые читают из канала и выводят в `stdout`.

**Подсказка:** Количество воркеров передаётся как параметр при запуске. Воркеры запускаются как горутины.

---

## 1.4 **Корректное завершение по Ctrl+C**

> **Задача:** При получении `SIGINT` (Ctrl+C) корректно завершать работу всех воркеров.

**Подсказка:** Использовать `context.Context` или канал для оповещения о завершении.

---

## 1.5 **Завершение программы через `time.After`**

> **Задача:** Последовательно отправлять значения в канал, читать их и завершить работу через `N` секунд.

**Подсказка:** Использовать `time.After` или `Timer`.

---

## 1.6 **Способы остановки горутин**

> **Задача:** Реализовать все способы остановки горутин:

* Выход по условию
* Закрытие канала-уведомления
* Использование `context`
* Прекращение через `runtime.Goexit()`

---

## 1.7 **Безопасная запись в `map`**

> **Задача:** Реализовать безопасную конкурентную запись в `map`.

**Подсказка:** Использовать `sync.Mutex`, `sync.Map` или другую синхронизацию.

**Дополнительно:** Запустить с `-race` для проверки на гонки.

---

## 1.8 **Установка i-го бита в числе**

> **Задача:** Установить `i`-й бит `int64` переменной в `1` или `0`.

**Пример:**
`5 (0101₂)` -> установить 1-й бит в `0` → `4 (0100₂)`

**Подсказка:** Используйте `|` и `&^`.

---

## 1.9 **Конвейер чисел**

> **Задача:** Два канала: в первый пишутся числа `x`, во второй — `x * 2`, и затем вывод в `stdout`.

**Подсказка:** Два этапа: генерация и обработка. Убедитесь в корректном завершении чтения.

---

## 1.10 **Группировка температур**

> **Задача:** Группировать значения с шагом в 10 градусов.

**Дано:**
`[-25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5]`

**Ожидаемый результат:**

```go
{
  -20: {-25.4, -27.0, -21.0},
   10: {13.0, 19.0, 15.5},
   20: {24.5},
   30: {32.5},
}
```

---

## 1.11 **Пересечение множеств**

> **Задача:** Найти пересечение двух слайсов.

**Пример:**
`A = {1,2,3}`
`B = {2,3,4}`
`→ {2,3}`

---

## 1.12 **Создание множества из строк**

> **Задача:** Создать множество (set) из последовательности строк:
> `("cat", "cat", "dog", "cat", "tree")`
> → `{"cat", "dog", "tree"}`

---

## 1.13 **Обмен значениями без временной переменной**

> **Задача:** Поменять местами два числа без использования временной переменной.

**Подсказка:** Использовать XOR или сложение/вычитание.

---

## 1.14 **Определение типа переменной**

> **Задача:** Определить тип `interface{}` переменной во время выполнения.
> Поддерживаемые типы: `int`, `string`, `bool`, `chan`.

**Подсказка:** Использовать `switch v := value.(type)`.

---

## 1.15 **Анализ кода с `justString`**

```go
var justString string

func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
```

> **Вопрос:** Какие проблемы здесь? Как это исправить?

**Ответ:** Срез `v[:100]` может захватывать весь backing array, не позволяя GC освободить память.
**Решение:** Скопировать подстроку явно: `justString = string([]byte(v[:100]))`

---

## 1.16 **Быстрая сортировка**

> **Задача:** Реализовать алгоритм **QuickSort** на Go.

**Подсказка:** Рекурсивно сортировать срез.

---

## 1.17 **Бинарный поиск**

> **Задача:** Реализовать бинарный поиск по отсортированному слайсу.

**Выход:** Индекс найденного элемента или `-1`.

---

## 1.18 **Конкурентный счётчик**

> **Задача:** Реализовать безопасный конкурентный счётчик.

**Подсказка:** Используйте `sync.Mutex` или `sync/atomic`.

---

## 1.19 **Переворот строки (Unicode)**

> **Задача:** Перевернуть строку, включая Unicode (русские буквы, emoji и пр.).

**Подсказка:** Использовать `[]rune`.

---

## 1.20 **Переворот слов в строке**

> **Задача:** В строке `«snow dog sun»` получить `«sun dog snow»`.

**Подсказка:** Слова разделены пробелами, старайтесь работать «на месте».

---

## 1.21 **Паттерн «Адаптер»**

> **Задача:** Реализовать паттерн **Adapter** — преобразовать один интерфейс в другой.

**Пример:** Клиент ждёт `Reader`, а у нас `LegacyReader`. Создайте `ReaderAdapter`, который реализует нужный интерфейс.

**Пояснение:**

* **Плюсы:** совместимость без изменения существующего кода.
* **Минусы:** дополнительные сущности, возможное усложнение.

---

## 1.22 **Арифметика больших чисел**

> **Задача:** Сложить/вычесть/умножить/разделить два числа > 2²⁰.

**Подсказка:** Использовать тип `int` или `math/big.Int` для очень больших значений.

---

## 1.23 **Удаление i-го элемента из слайса**

> **Задача:** Удалить элемент с индексом `i`, корректно освободив память.

**Подсказка:**

```go
slice = append(slice[:i], slice[i+1:]...)
```

Или:

```go
copy(slice[i:], slice[i+1:])
slice = slice[:len(slice)-1]
```

---

## 1.24 **Расстояние между точками**

> **Задача:** Структура `Point` с приватными полями и методом `Distance()`.

**Подсказка:** Использовать конструктор `NewPoint(x, y float64)`.

---

## 1.25 **Собственная функция Sleep**

> **Задача:** Реализовать `mySleep(duration)` без использования `time.Sleep`.

**Подсказка:** Можно использовать `time.After`, каналы или цикл с проверкой времени.

---

## 1.26 **Проверка уникальности символов в строке**

> **Задача:** Вернуть `true`, если все символы строки уникальны (без учёта регистра).

**Пример:**

* `"abcd"` → `true`
* `"abCdefAaf"` → `false`

**Подсказка:** Используйте `map[rune]bool` и `strings.ToLower()`.
