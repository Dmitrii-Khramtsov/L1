# Задачи: concurrency, алгоритмы и структуры данных

## 1.1 **Встраивание структур**

> **Задача:** дана структура `Human` (с произвольным набором полей и методов).

> Реализовать встраивание методов в структуре `Action` от родительской структуры `Human` (аналог наследования).

**Подсказка:** используйте композицию (embedded struct), чтобы `Action` имел все методы `Human`.

---

## 1.2 **Конкурентное возведение в квадрат**

> **Задача:** написать программу, которая конкурентно рассчитает значения квадратов чисел, взятых из массива `[2,4,6,8,10]`, и выведет результаты в `stdout`.

**Подсказка:** запусти несколько горутин, каждая из которых возводит число в квадрат.

---

## 1.3 **Работа нескольких воркеров**

> **Задача:** реализовать постоянную запись данных в канал (в главной горутине).

> Реализовать набор из `N воркеров`, которые читают данные из этого канала и выводят их в `stdout`.

**Подсказка:** программа должна принимать параметром количество воркеров и при старте создавать указанное число горутин-воркеров.

---

## 1.4 **Завершение по Ctrl+C**

> **Задача:** программа должна корректно завершаться по нажатию Ctrl+C (`SIGINT`).

> Выберите и обоснуйте способ завершения работы всех горутин-воркеров при получении сигнала прерывания.

**Подсказка:** можно использовать контекст (context.Context) или канал для оповещения о завершении.

---

## 1.5 **Таймаут на канал**

> **Задача:** разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала – читать эти значения. По истечении `N` секунд программа должна завершаться.

**Подсказка:** используйте `time.After` или `таймер` для ограничения времени работы.

---

## 1.6 **Остановка горутины**

> **Задача:** Реализовать все возможные способы остановки выполнения горутины.

> Классические подходы: выход по условию, через канал уведомления, через контекст, прекращение работы `runtime`.`Goexit()` и др.

> Продемонстрируйте каждый способ в отдельном фрагменте кода.

---

## 1.7 **Конкурентная запись в `map`**

> **Задача:** реализовать безопасную для конкуренции запись данных в структуру map.

**Подсказка:** необходимость использования синхронизации (например, `sync.Mutex` или встроенная `concurrent-map`).

**Дополнительно:** Проверьте работу кода на гонки (util go run `-race`).

---

## 1.8 **Установка бита в числе**

> **Задача:** дана переменная типа int64. Разработать программу, которая устанавливает i-й бит этого числа в 1 или 0.

**Пример:** для числа 5 (0101₂) установка 1-го бита в 0 даст 4 (0100₂).

**Подсказка:** используйте битовые операции (`|`, `&``^`).

---

## 1.9 **Конвейер чисел**

> Разработать конвейер чисел. Даны два канала: в первый пишутся числа x из массива, во второй – результат операции x*2. После этого данные из второго канала должны выводиться в stdout. То есть, организуйте конвейер из двух этапов с горутинами: генерация чисел и их обработка. Убедитесь, что чтение из второго канала корректно завершается.

---

## 1.10 **Группировка температур**

> **Задача:** Дана последовательность температурных колебаний: -25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить эти значения в группы с шагом 10 градусов.

**Пример:** `-20:{-25.4, -27.0, -21.0}`, `10:{13.0, 19.0, 15.5}`, `20:{24.5}`, `30:{32.5}`.

**Пояснение:** диапазон `-20` включает значения `от -20 до -29.9`, диапазон `10` – `от 10 до 19.9`, и т.д. Порядок в подмножествах не важен.

---

## 1.11 **Пересечение множеств**

> **Задача:** Реализовать пересечение двух неупорядоченных множеств (например, двух слайсов) — т.е. вывести элементы, присутствующие и в первом, и во втором.

**Пример:**
`A = {1,2,3}`
`B = {2,3,4}`
Пересечение = `{2,3}`

---

## 1.12 **Собственное множество строк**

> **Задача:** Имеется последовательность строк: ("cat", "cat", "dog", "cat", "tree"). Создать для неё собственное множество.

**Ожидается:** получить набор уникальных слов. Для примера, множество = {"cat", "dog", "tree"}.

---

## 1.13 **Обмен значениями без третьей переменной**

> **Задача:** Поменять местами два числа без использования временной переменной.

**Подсказка:** примените сложение/вычитание или XOR-обмен.

---

## 1.14 **Определение типа переменной в runtime**

> **Задача:** Разработать программу, которая в runtime способна определить тип переменной, переданной в неё (на вход подаётся interface{}). Типы, которые нужно распознавать: int, string, bool, chan (канал).

**Подсказка:** оператор типа `switch v.(type)` поможет в решении.

---

## 1.15 **Небольшой фрагмент кода — проблемы и решение**

> **Задача:** Рассмотреть следующий код и ответить на вопросы: к каким негативным последствиям он может привести и как это исправить?

_Приведите корректный пример реализации._

```go
var justString string

func someFunc() {
  v := createHugeString(1 &lt;&lt; 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
```

> **Вопрос:** Вопрос: что происходит с переменной justString?

**Ответ:** в Go строки `иммутабельны`, и `срез строки хранит указатель` на данные исходной строки и длину, поэтому при работе с большими строками нужно `явно копировать`, `если нужен только небольшой кусок`.
**Решение:** Скопировать подстроку явно: `justString = string([]byte(v[:100]))`

---

## 1.16 **Быстрая сортировка (quicksort)**

> **Задача:** Реализовать алгоритм быстрой сортировки массива встроенными средствами языка. Можно использовать рекурсию.

**Подсказка:** напишите функцию `quickSort([]int) []int` которая сортирует срез целых чисел. Для выбора опорного элемента можно взять середину или первый элемент.

---

## 1.17 **Бинарный поиск**

> **Задача:** Реализовать алгоритм бинарного поиска встроенными методами языка. Функция должна принимать отсортированный слайс и искомый элемент, возвращать индекс элемента или `-1`, если элемент не найден.

**Подсказка:** можно реализовать `рекурсивно` или `итеративно`, используя цикл for.

---

## 1.18 **Конкурентный счётчик**

> **Задача:** Реализовать структуру-счётчик, которая будет инкрементироваться в конкурентной среде (т.е. из нескольких горутин). По завершению программы структура должна выводить итоговое значение счётчика.

**Подсказка:** вам понадобится механизм синхронизации, например, sync.Mutex или sync/Atomic для безопасного инкремента.

---

## 1.19 **Разворот строки**

> **Задача:** Разработать программу, которая переворачивает подаваемую на вход строку.

**Например:** при вводе строки `«главрыба»` вывод должен быть `«абырвалг».`

**Подсказка:** учтите, что символы могут быть в `Unicode` (русские буквы, emoji и пр.), то есть просто iterating по байтам может не подойти — нужен срез рун (`[]rune`).

---

## 1.20 **Разворот слов в предложении**

> **Задача:** Разработать программу, которая переворачивает порядок слов в строке.

**Пример:** входная строка:

`«snow dog sun»`, выход: `«sun dog snow»`.

**Подсказка:** Считайте, что слова разделяются одиночным пробелом. Постарайтесь не использовать дополнительные срезы, а выполнять операцию «на месте».

---

## 1.21 **Паттерн «Адаптер»**

> **Задача:** Реализовать паттерн проектирования «Адаптер» на любом примере.

**Описание:** паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой, несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.

**Пояснение:**
* **Плюсы:** позволяет использовать «несовместимый» код без переписывания.
* **Минусы:** добавляет слой абстракции и может немного усложнить код.

---

## 1.22 **Большие числа и операции**

> **Задача:** Разработать программу, которая перемножает, делит, складывает, вычитает две числовых переменных a, b, значения которых > 2^20 (больше 1 миллион).

**Комментарий:** в Go тип int справится с такими числами, но обратите внимание на возможное переполнение для ещё больших значений. Для очень больших чисел можно использовать math/big.

---

## 1.23 **Удаление элемента слайса**

> **Задача:** Удалить `i-ый` элемент из слайса. Продемонстрируйте корректное удаление без утечки памяти.

**Подсказка:** можно сдвинуть хвост слайса на место удаляемого элемента `(copy(slice[i:], slice[i+1:]))` и уменьшить длину слайса на 1.

---

## 1.24 **Расстояние между точками**

> **Задача:** Разработать программу нахождения расстояния между двумя точками на плоскости. Точки представлены в виде структуры `Point` с инкапсулированными (приватными) полями `x`, `y` (типа `float64`) и `конструктором`. Расстояние рассчитывается по формуле между координатами двух точек.

**Подсказка:** используйте функцию-конструктор `NewPoint(x, y)`, `Point` и метод `Distance(other Point) float64`.

---

## 1.25 **Собственная функция Sleep**

> **Задача:** Реализовать собственную функцию `sleep(duration)` аналогично встроенной функции `time.Sleep`, которая приостанавливает выполнение текущей горутины.

**Важно:** в отличии от настоящей time.Sleep, ваша функция должна именно блокировать выполнение (например, через таймер или цикл), а не просто вызывать time.Sleep :) — это упражнение.

**Подсказка:** Можно использовать канал + горутину, или цикл на проверку времени (не лучший способ, но для обучения).

---

## 1.26 **Проверка уникальности символов в строке**

> **Задача:** Разработать программу, которая проверяет, что все символы в строке встречаются один раз (т.е. строка состоит из уникальных символов).

**Вывод:** true, если все символы уникальны, false, если есть повторения. Проверка должна быть регистронезависимой, т.е. символы в разных регистрах считать одинаковыми.

**Например:** "abcd" -> true, "abCdefAaf" -> false (повторяются a/A), "aabcd" -> false.

**Подсказка:** Подумайте, какой структурой данных удобно воспользоваться для проверки условия.
